// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'create_coupon_cubit_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CreateCouponState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCouponStateCopyWith<T, $Res> {
  factory $CreateCouponStateCopyWith(CreateCouponState<T> value,
          $Res Function(CreateCouponState<T>) then) =
      _$CreateCouponStateCopyWithImpl<T, $Res, CreateCouponState<T>>;
}

/// @nodoc
class _$CreateCouponStateCopyWithImpl<T, $Res,
        $Val extends CreateCouponState<T>>
    implements $CreateCouponStateCopyWith<T, $Res> {
  _$CreateCouponStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<T, $Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl<T> value, $Res Function(_$InitialImpl<T>) then) =
      __$$InitialImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$InitialImpl<T>>
    implements _$$InitialImplCopyWith<T, $Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl<T> _value, $Res Function(_$InitialImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl<T> with DiagnosticableTreeMixin implements _Initial<T> {
  const _$InitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'CreateCouponState<$T>.initial'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial<T> implements CreateCouponState<T> {
  const factory _Initial() = _$InitialImpl<T>;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<T, $Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl<T> value, $Res Function(_$LoadingImpl<T>) then) =
      __$$LoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$LoadingImpl<T>>
    implements _$$LoadingImplCopyWith<T, $Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl<T> _value, $Res Function(_$LoadingImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl<T> with DiagnosticableTreeMixin implements Loading<T> {
  const _$LoadingImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'CreateCouponState<$T>.loading'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class Loading<T> implements CreateCouponState<T> {
  const factory Loading() = _$LoadingImpl<T>;
}

/// @nodoc
abstract class _$$SuccessImplCopyWith<T, $Res> {
  factory _$$SuccessImplCopyWith(
          _$SuccessImpl<T> value, $Res Function(_$SuccessImpl<T>) then) =
      __$$SuccessImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$SuccessImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$SuccessImpl<T>>
    implements _$$SuccessImplCopyWith<T, $Res> {
  __$$SuccessImplCopyWithImpl(
      _$SuccessImpl<T> _value, $Res Function(_$SuccessImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SuccessImpl<T> with DiagnosticableTreeMixin implements Success<T> {
  const _$SuccessImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.success()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'CreateCouponState<$T>.success'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SuccessImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class Success<T> implements CreateCouponState<T> {
  const factory Success() = _$SuccessImpl<T>;
}

/// @nodoc
abstract class _$$FaluireImplCopyWith<T, $Res> {
  factory _$$FaluireImplCopyWith(
          _$FaluireImpl<T> value, $Res Function(_$FaluireImpl<T>) then) =
      __$$FaluireImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$FaluireImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$FaluireImpl<T>>
    implements _$$FaluireImplCopyWith<T, $Res> {
  __$$FaluireImplCopyWithImpl(
      _$FaluireImpl<T> _value, $Res Function(_$FaluireImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$FaluireImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FaluireImpl<T> with DiagnosticableTreeMixin implements Faluire<T> {
  const _$FaluireImpl({required this.error});

  @override
  final String error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.faluire(error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CreateCouponState<$T>.faluire'))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FaluireImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FaluireImplCopyWith<T, _$FaluireImpl<T>> get copyWith =>
      __$$FaluireImplCopyWithImpl<T, _$FaluireImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return faluire(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return faluire?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (faluire != null) {
      return faluire(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return faluire(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return faluire?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (faluire != null) {
      return faluire(this);
    }
    return orElse();
  }
}

abstract class Faluire<T> implements CreateCouponState<T> {
  const factory Faluire({required final String error}) = _$FaluireImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$FaluireImplCopyWith<T, _$FaluireImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DateSelectedImplCopyWith<T, $Res> {
  factory _$$DateSelectedImplCopyWith(_$DateSelectedImpl<T> value,
          $Res Function(_$DateSelectedImpl<T>) then) =
      __$$DateSelectedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({DateTime selectedDate});
}

/// @nodoc
class __$$DateSelectedImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$DateSelectedImpl<T>>
    implements _$$DateSelectedImplCopyWith<T, $Res> {
  __$$DateSelectedImplCopyWithImpl(
      _$DateSelectedImpl<T> _value, $Res Function(_$DateSelectedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedDate = null,
  }) {
    return _then(_$DateSelectedImpl<T>(
      selectedDate: null == selectedDate
          ? _value.selectedDate
          : selectedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$DateSelectedImpl<T>
    with DiagnosticableTreeMixin
    implements DateSelected<T> {
  const _$DateSelectedImpl({required this.selectedDate});

  @override
  final DateTime selectedDate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.dateSelected(selectedDate: $selectedDate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CreateCouponState<$T>.dateSelected'))
      ..add(DiagnosticsProperty('selectedDate', selectedDate));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DateSelectedImpl<T> &&
            (identical(other.selectedDate, selectedDate) ||
                other.selectedDate == selectedDate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, selectedDate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DateSelectedImplCopyWith<T, _$DateSelectedImpl<T>> get copyWith =>
      __$$DateSelectedImplCopyWithImpl<T, _$DateSelectedImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return dateSelected(selectedDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return dateSelected?.call(selectedDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (dateSelected != null) {
      return dateSelected(selectedDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return dateSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return dateSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (dateSelected != null) {
      return dateSelected(this);
    }
    return orElse();
  }
}

abstract class DateSelected<T> implements CreateCouponState<T> {
  const factory DateSelected({required final DateTime selectedDate}) =
      _$DateSelectedImpl<T>;

  DateTime get selectedDate;
  @JsonKey(ignore: true)
  _$$DateSelectedImplCopyWith<T, _$DateSelectedImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CategorySelectedImplCopyWith<T, $Res> {
  factory _$$CategorySelectedImplCopyWith(_$CategorySelectedImpl<T> value,
          $Res Function(_$CategorySelectedImpl<T>) then) =
      __$$CategorySelectedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({CategoryModel optionItemSelected});
}

/// @nodoc
class __$$CategorySelectedImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$CategorySelectedImpl<T>>
    implements _$$CategorySelectedImplCopyWith<T, $Res> {
  __$$CategorySelectedImplCopyWithImpl(_$CategorySelectedImpl<T> _value,
      $Res Function(_$CategorySelectedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? optionItemSelected = null,
  }) {
    return _then(_$CategorySelectedImpl<T>(
      optionItemSelected: null == optionItemSelected
          ? _value.optionItemSelected
          : optionItemSelected // ignore: cast_nullable_to_non_nullable
              as CategoryModel,
    ));
  }
}

/// @nodoc

class _$CategorySelectedImpl<T>
    with DiagnosticableTreeMixin
    implements CategorySelected<T> {
  const _$CategorySelectedImpl({required this.optionItemSelected});

  @override
  final CategoryModel optionItemSelected;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.categorySelected(optionItemSelected: $optionItemSelected)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'CreateCouponState<$T>.categorySelected'))
      ..add(DiagnosticsProperty('optionItemSelected', optionItemSelected));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CategorySelectedImpl<T> &&
            (identical(other.optionItemSelected, optionItemSelected) ||
                other.optionItemSelected == optionItemSelected));
  }

  @override
  int get hashCode => Object.hash(runtimeType, optionItemSelected);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CategorySelectedImplCopyWith<T, _$CategorySelectedImpl<T>> get copyWith =>
      __$$CategorySelectedImplCopyWithImpl<T, _$CategorySelectedImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return categorySelected(optionItemSelected);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return categorySelected?.call(optionItemSelected);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (categorySelected != null) {
      return categorySelected(optionItemSelected);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return categorySelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return categorySelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (categorySelected != null) {
      return categorySelected(this);
    }
    return orElse();
  }
}

abstract class CategorySelected<T> implements CreateCouponState<T> {
  const factory CategorySelected(
          {required final CategoryModel optionItemSelected}) =
      _$CategorySelectedImpl<T>;

  CategoryModel get optionItemSelected;
  @JsonKey(ignore: true)
  _$$CategorySelectedImplCopyWith<T, _$CategorySelectedImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CategoriesLoadedImplCopyWith<T, $Res> {
  factory _$$CategoriesLoadedImplCopyWith(_$CategoriesLoadedImpl<T> value,
          $Res Function(_$CategoriesLoadedImpl<T>) then) =
      __$$CategoriesLoadedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({DropListModel listOfCategoriesOption});
}

/// @nodoc
class __$$CategoriesLoadedImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$CategoriesLoadedImpl<T>>
    implements _$$CategoriesLoadedImplCopyWith<T, $Res> {
  __$$CategoriesLoadedImplCopyWithImpl(_$CategoriesLoadedImpl<T> _value,
      $Res Function(_$CategoriesLoadedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listOfCategoriesOption = null,
  }) {
    return _then(_$CategoriesLoadedImpl<T>(
      listOfCategoriesOption: null == listOfCategoriesOption
          ? _value.listOfCategoriesOption
          : listOfCategoriesOption // ignore: cast_nullable_to_non_nullable
              as DropListModel,
    ));
  }
}

/// @nodoc

class _$CategoriesLoadedImpl<T>
    with DiagnosticableTreeMixin
    implements CategoriesLoaded<T> {
  const _$CategoriesLoadedImpl({required this.listOfCategoriesOption});

  @override
  final DropListModel listOfCategoriesOption;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.categoriesLoaded(listOfCategoriesOption: $listOfCategoriesOption)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'CreateCouponState<$T>.categoriesLoaded'))
      ..add(DiagnosticsProperty(
          'listOfCategoriesOption', listOfCategoriesOption));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CategoriesLoadedImpl<T> &&
            (identical(other.listOfCategoriesOption, listOfCategoriesOption) ||
                other.listOfCategoriesOption == listOfCategoriesOption));
  }

  @override
  int get hashCode => Object.hash(runtimeType, listOfCategoriesOption);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CategoriesLoadedImplCopyWith<T, _$CategoriesLoadedImpl<T>> get copyWith =>
      __$$CategoriesLoadedImplCopyWithImpl<T, _$CategoriesLoadedImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return categoriesLoaded(listOfCategoriesOption);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return categoriesLoaded?.call(listOfCategoriesOption);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (categoriesLoaded != null) {
      return categoriesLoaded(listOfCategoriesOption);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return categoriesLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return categoriesLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (categoriesLoaded != null) {
      return categoriesLoaded(this);
    }
    return orElse();
  }
}

abstract class CategoriesLoaded<T> implements CreateCouponState<T> {
  const factory CategoriesLoaded(
          {required final DropListModel listOfCategoriesOption}) =
      _$CategoriesLoadedImpl<T>;

  DropListModel get listOfCategoriesOption;
  @JsonKey(ignore: true)
  _$$CategoriesLoadedImplCopyWith<T, _$CategoriesLoadedImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadingSetLogoStoreImplCopyWith<T, $Res> {
  factory _$$LoadingSetLogoStoreImplCopyWith(_$LoadingSetLogoStoreImpl<T> value,
          $Res Function(_$LoadingSetLogoStoreImpl<T>) then) =
      __$$LoadingSetLogoStoreImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$LoadingSetLogoStoreImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res,
        _$LoadingSetLogoStoreImpl<T>>
    implements _$$LoadingSetLogoStoreImplCopyWith<T, $Res> {
  __$$LoadingSetLogoStoreImplCopyWithImpl(_$LoadingSetLogoStoreImpl<T> _value,
      $Res Function(_$LoadingSetLogoStoreImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingSetLogoStoreImpl<T>
    with DiagnosticableTreeMixin
    implements LoadingSetLogoStore<T> {
  const _$LoadingSetLogoStoreImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.loadingSetLogoStore()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'CreateCouponState<$T>.loadingSetLogoStore'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingSetLogoStoreImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return loadingSetLogoStore();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return loadingSetLogoStore?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (loadingSetLogoStore != null) {
      return loadingSetLogoStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return loadingSetLogoStore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return loadingSetLogoStore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (loadingSetLogoStore != null) {
      return loadingSetLogoStore(this);
    }
    return orElse();
  }
}

abstract class LoadingSetLogoStore<T> implements CreateCouponState<T> {
  const factory LoadingSetLogoStore() = _$LoadingSetLogoStoreImpl<T>;
}

/// @nodoc
abstract class _$$LoadedSetLogoStoreImplCopyWith<T, $Res> {
  factory _$$LoadedSetLogoStoreImplCopyWith(_$LoadedSetLogoStoreImpl<T> value,
          $Res Function(_$LoadedSetLogoStoreImpl<T>) then) =
      __$$LoadedSetLogoStoreImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({XFile imageURL});
}

/// @nodoc
class __$$LoadedSetLogoStoreImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res,
        _$LoadedSetLogoStoreImpl<T>>
    implements _$$LoadedSetLogoStoreImplCopyWith<T, $Res> {
  __$$LoadedSetLogoStoreImplCopyWithImpl(_$LoadedSetLogoStoreImpl<T> _value,
      $Res Function(_$LoadedSetLogoStoreImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? imageURL = null,
  }) {
    return _then(_$LoadedSetLogoStoreImpl<T>(
      imageURL: null == imageURL
          ? _value.imageURL
          : imageURL // ignore: cast_nullable_to_non_nullable
              as XFile,
    ));
  }
}

/// @nodoc

class _$LoadedSetLogoStoreImpl<T>
    with DiagnosticableTreeMixin
    implements LoadedSetLogoStore<T> {
  const _$LoadedSetLogoStoreImpl({required this.imageURL});

  @override
  final XFile imageURL;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.loadedSetLogoStore(imageURL: $imageURL)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'CreateCouponState<$T>.loadedSetLogoStore'))
      ..add(DiagnosticsProperty('imageURL', imageURL));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedSetLogoStoreImpl<T> &&
            (identical(other.imageURL, imageURL) ||
                other.imageURL == imageURL));
  }

  @override
  int get hashCode => Object.hash(runtimeType, imageURL);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedSetLogoStoreImplCopyWith<T, _$LoadedSetLogoStoreImpl<T>>
      get copyWith => __$$LoadedSetLogoStoreImplCopyWithImpl<T,
          _$LoadedSetLogoStoreImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return loadedSetLogoStore(imageURL);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return loadedSetLogoStore?.call(imageURL);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (loadedSetLogoStore != null) {
      return loadedSetLogoStore(imageURL);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return loadedSetLogoStore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return loadedSetLogoStore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (loadedSetLogoStore != null) {
      return loadedSetLogoStore(this);
    }
    return orElse();
  }
}

abstract class LoadedSetLogoStore<T> implements CreateCouponState<T> {
  const factory LoadedSetLogoStore({required final XFile imageURL}) =
      _$LoadedSetLogoStoreImpl<T>;

  XFile get imageURL;
  @JsonKey(ignore: true)
  _$$LoadedSetLogoStoreImplCopyWith<T, _$LoadedSetLogoStoreImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NotSelectedLogoStoreImplCopyWith<T, $Res> {
  factory _$$NotSelectedLogoStoreImplCopyWith(
          _$NotSelectedLogoStoreImpl<T> value,
          $Res Function(_$NotSelectedLogoStoreImpl<T>) then) =
      __$$NotSelectedLogoStoreImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$NotSelectedLogoStoreImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res,
        _$NotSelectedLogoStoreImpl<T>>
    implements _$$NotSelectedLogoStoreImplCopyWith<T, $Res> {
  __$$NotSelectedLogoStoreImplCopyWithImpl(_$NotSelectedLogoStoreImpl<T> _value,
      $Res Function(_$NotSelectedLogoStoreImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotSelectedLogoStoreImpl<T>
    with DiagnosticableTreeMixin
    implements NotSelectedLogoStore<T> {
  const _$NotSelectedLogoStoreImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.notSelectedLogoStore()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'CreateCouponState<$T>.notSelectedLogoStore'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotSelectedLogoStoreImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return notSelectedLogoStore();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return notSelectedLogoStore?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (notSelectedLogoStore != null) {
      return notSelectedLogoStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return notSelectedLogoStore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return notSelectedLogoStore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (notSelectedLogoStore != null) {
      return notSelectedLogoStore(this);
    }
    return orElse();
  }
}

abstract class NotSelectedLogoStore<T> implements CreateCouponState<T> {
  const factory NotSelectedLogoStore() = _$NotSelectedLogoStoreImpl<T>;
}

/// @nodoc
abstract class _$$EmptyLogoStoreImplCopyWith<T, $Res> {
  factory _$$EmptyLogoStoreImplCopyWith(_$EmptyLogoStoreImpl<T> value,
          $Res Function(_$EmptyLogoStoreImpl<T>) then) =
      __$$EmptyLogoStoreImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$EmptyLogoStoreImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$EmptyLogoStoreImpl<T>>
    implements _$$EmptyLogoStoreImplCopyWith<T, $Res> {
  __$$EmptyLogoStoreImplCopyWithImpl(_$EmptyLogoStoreImpl<T> _value,
      $Res Function(_$EmptyLogoStoreImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmptyLogoStoreImpl<T>
    with DiagnosticableTreeMixin
    implements EmptyLogoStore<T> {
  const _$EmptyLogoStoreImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.emptyLogoStore()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'CreateCouponState<$T>.emptyLogoStore'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyLogoStoreImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return emptyLogoStore();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return emptyLogoStore?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (emptyLogoStore != null) {
      return emptyLogoStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return emptyLogoStore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return emptyLogoStore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (emptyLogoStore != null) {
      return emptyLogoStore(this);
    }
    return orElse();
  }
}

abstract class EmptyLogoStore<T> implements CreateCouponState<T> {
  const factory EmptyLogoStore() = _$EmptyLogoStoreImpl<T>;
}

/// @nodoc
abstract class _$$CouponLoadedImplCopyWith<T, $Res> {
  factory _$$CouponLoadedImplCopyWith(_$CouponLoadedImpl<T> value,
          $Res Function(_$CouponLoadedImpl<T>) then) =
      __$$CouponLoadedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({Coupon coupon});
}

/// @nodoc
class __$$CouponLoadedImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$CouponLoadedImpl<T>>
    implements _$$CouponLoadedImplCopyWith<T, $Res> {
  __$$CouponLoadedImplCopyWithImpl(
      _$CouponLoadedImpl<T> _value, $Res Function(_$CouponLoadedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coupon = null,
  }) {
    return _then(_$CouponLoadedImpl<T>(
      coupon: null == coupon
          ? _value.coupon
          : coupon // ignore: cast_nullable_to_non_nullable
              as Coupon,
    ));
  }
}

/// @nodoc

class _$CouponLoadedImpl<T>
    with DiagnosticableTreeMixin
    implements CouponLoaded<T> {
  const _$CouponLoadedImpl({required this.coupon});

  @override
  final Coupon coupon;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.couponLoaded(coupon: $coupon)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CreateCouponState<$T>.couponLoaded'))
      ..add(DiagnosticsProperty('coupon', coupon));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CouponLoadedImpl<T> &&
            (identical(other.coupon, coupon) || other.coupon == coupon));
  }

  @override
  int get hashCode => Object.hash(runtimeType, coupon);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CouponLoadedImplCopyWith<T, _$CouponLoadedImpl<T>> get copyWith =>
      __$$CouponLoadedImplCopyWithImpl<T, _$CouponLoadedImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return couponLoaded(coupon);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return couponLoaded?.call(coupon);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (couponLoaded != null) {
      return couponLoaded(coupon);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return couponLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return couponLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (couponLoaded != null) {
      return couponLoaded(this);
    }
    return orElse();
  }
}

abstract class CouponLoaded<T> implements CreateCouponState<T> {
  const factory CouponLoaded({required final Coupon coupon}) =
      _$CouponLoadedImpl<T>;

  Coupon get coupon;
  @JsonKey(ignore: true)
  _$$CouponLoadedImplCopyWith<T, _$CouponLoadedImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StopLoadingImageImplCopyWith<T, $Res> {
  factory _$$StopLoadingImageImplCopyWith(_$StopLoadingImageImpl<T> value,
          $Res Function(_$StopLoadingImageImpl<T>) then) =
      __$$StopLoadingImageImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$StopLoadingImageImplCopyWithImpl<T, $Res>
    extends _$CreateCouponStateCopyWithImpl<T, $Res, _$StopLoadingImageImpl<T>>
    implements _$$StopLoadingImageImplCopyWith<T, $Res> {
  __$$StopLoadingImageImplCopyWithImpl(_$StopLoadingImageImpl<T> _value,
      $Res Function(_$StopLoadingImageImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StopLoadingImageImpl<T>
    with DiagnosticableTreeMixin
    implements StopLoadingImage<T> {
  const _$StopLoadingImageImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCouponState<$T>.stopLoadingImage()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'CreateCouponState<$T>.stopLoadingImage'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StopLoadingImageImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function(String error) faluire,
    required TResult Function(DateTime selectedDate) dateSelected,
    required TResult Function(CategoryModel optionItemSelected)
        categorySelected,
    required TResult Function(DropListModel listOfCategoriesOption)
        categoriesLoaded,
    required TResult Function() loadingSetLogoStore,
    required TResult Function(XFile imageURL) loadedSetLogoStore,
    required TResult Function() notSelectedLogoStore,
    required TResult Function() emptyLogoStore,
    required TResult Function(Coupon coupon) couponLoaded,
    required TResult Function() stopLoadingImage,
  }) {
    return stopLoadingImage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function(String error)? faluire,
    TResult? Function(DateTime selectedDate)? dateSelected,
    TResult? Function(CategoryModel optionItemSelected)? categorySelected,
    TResult? Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult? Function()? loadingSetLogoStore,
    TResult? Function(XFile imageURL)? loadedSetLogoStore,
    TResult? Function()? notSelectedLogoStore,
    TResult? Function()? emptyLogoStore,
    TResult? Function(Coupon coupon)? couponLoaded,
    TResult? Function()? stopLoadingImage,
  }) {
    return stopLoadingImage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function(String error)? faluire,
    TResult Function(DateTime selectedDate)? dateSelected,
    TResult Function(CategoryModel optionItemSelected)? categorySelected,
    TResult Function(DropListModel listOfCategoriesOption)? categoriesLoaded,
    TResult Function()? loadingSetLogoStore,
    TResult Function(XFile imageURL)? loadedSetLogoStore,
    TResult Function()? notSelectedLogoStore,
    TResult Function()? emptyLogoStore,
    TResult Function(Coupon coupon)? couponLoaded,
    TResult Function()? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (stopLoadingImage != null) {
      return stopLoadingImage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(Loading<T> value) loading,
    required TResult Function(Success<T> value) success,
    required TResult Function(Faluire<T> value) faluire,
    required TResult Function(DateSelected<T> value) dateSelected,
    required TResult Function(CategorySelected<T> value) categorySelected,
    required TResult Function(CategoriesLoaded<T> value) categoriesLoaded,
    required TResult Function(LoadingSetLogoStore<T> value) loadingSetLogoStore,
    required TResult Function(LoadedSetLogoStore<T> value) loadedSetLogoStore,
    required TResult Function(NotSelectedLogoStore<T> value)
        notSelectedLogoStore,
    required TResult Function(EmptyLogoStore<T> value) emptyLogoStore,
    required TResult Function(CouponLoaded<T> value) couponLoaded,
    required TResult Function(StopLoadingImage<T> value) stopLoadingImage,
  }) {
    return stopLoadingImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(Loading<T> value)? loading,
    TResult? Function(Success<T> value)? success,
    TResult? Function(Faluire<T> value)? faluire,
    TResult? Function(DateSelected<T> value)? dateSelected,
    TResult? Function(CategorySelected<T> value)? categorySelected,
    TResult? Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult? Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult? Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult? Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult? Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult? Function(CouponLoaded<T> value)? couponLoaded,
    TResult? Function(StopLoadingImage<T> value)? stopLoadingImage,
  }) {
    return stopLoadingImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(Loading<T> value)? loading,
    TResult Function(Success<T> value)? success,
    TResult Function(Faluire<T> value)? faluire,
    TResult Function(DateSelected<T> value)? dateSelected,
    TResult Function(CategorySelected<T> value)? categorySelected,
    TResult Function(CategoriesLoaded<T> value)? categoriesLoaded,
    TResult Function(LoadingSetLogoStore<T> value)? loadingSetLogoStore,
    TResult Function(LoadedSetLogoStore<T> value)? loadedSetLogoStore,
    TResult Function(NotSelectedLogoStore<T> value)? notSelectedLogoStore,
    TResult Function(EmptyLogoStore<T> value)? emptyLogoStore,
    TResult Function(CouponLoaded<T> value)? couponLoaded,
    TResult Function(StopLoadingImage<T> value)? stopLoadingImage,
    required TResult orElse(),
  }) {
    if (stopLoadingImage != null) {
      return stopLoadingImage(this);
    }
    return orElse();
  }
}

abstract class StopLoadingImage<T> implements CreateCouponState<T> {
  const factory StopLoadingImage() = _$StopLoadingImageImpl<T>;
}
